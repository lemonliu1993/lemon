动态代理，也有搞不定的时候，比如要代理一个没有任何接口的类，它就没有用武之地了！

代理没有接口的类——CGLib类库，它是一个在运行期间动态生成字节码的工具，也就是动态生成代理类了。

cglib提供的是方法级别的代理，也可以理解为对方法的拦截（"这就是传说中的方法拦截器"）。

切面是AOP中的一个术语，表示从业务逻辑中分离出去的横切逻辑，比如性能监控，日志记录，权限控制等，这些功能都可以从核心的业务逻辑代码中抽离出去。
也就是说，通过AOP可以解决代码耦合问题，让职责更单一。

AOP：前置增强，后置增强，环绕增强(编程式)
before在Spring AOP里就叫Before Advice(前置增强)  Advice不翻译为通知，而是对原有代码功能的一种"增强"。CGLib中也有一个Enhancer类，它也是一个增强类
after叫After Advice(后置增强)，因为它放在后面来增强代码的功能。
before和after合并在一起，叫Around Advice(环绕增强)。

能否对类进行增强呢？用AOP的行话来讲，对方法的增强叫做Weaving(织入)，对类的增强叫做Introduction(引入).
Introduction Advice(引入增强)就是对类的功能增强，它也是Spring AOP提供的最后一种增强。

之前谈到的AOP框架可以将它理解为一个拦截器框架，但这个拦截器非常武断。比如它拦截了一个类，它就拦截了类中所有的方法。
类似的，我们在使用动态代理的时候，也遇到了这个问题，需要在代码中对所拦截的方法名加以判断，才能过滤出我们需要拦截的方法，这种做法确实不太优雅。

在大量的真实项目中，似乎我们只要拦截特定的方法就行了，没必要拦截所有的方法。于是AOP提供了一个很重要的工具————Advisor(切面)
切面是AOP的核心，是我们关注的重点。
也就是说，我们可以通过切面，将增强类与拦截匹配条件组合在一起，然后将这个切面配置到ProxyFactory中，从而生成代理。
这里提到这个"拦截匹配条件"在AOP中就叫做Pointcut(切点)，其实说白了就是一个基于表达式的拦截条件。
Advisor(切面)封装了Advice(增强)与Pointcut(切点)。

既然CGLib可以代理任何类类，那为什么还要用JDK的动态代理呢？
根据实际项目经验得知，CGLib创建代理的速度毕竟慢，但创建代理后运行的速度却非常快，而JDK动态代理正好相反。
如果在运行的时候不断的用CGlib去创建代理，系统的性能会大打折扣，所以建议一般在系统初始化的时候用CGLib去创建代理，病放入Spring的ApplicationContext中以备后用。

我们使用CGLib提供的Enhancer#create方法来创建代理对象，将intercept的参数传入ProxyChain的构造器中即可。
谁来调用ProxyManager呢？当然是切面类了，因为在切面类中，需要在目标方法被调用的前后增加相应的逻辑。
我们有必要写一个抽象类，让它提供一个模版方法，并在该抽象类的具体实现中扩展相应的抽象方法。
